N;ERC;NLR;CTL
1;20;The token must provide a way to check its total supply as a number.;AG(EX(totalSupply_is_number))
2;20;The token must allow anyone to check the balance of any address.;AG(EX(check_balance(address) => balance_is_number))
3;20;A token transfer must fail if the sender doesn’t have enough tokens.;AG(sender_balance < amount -> AX(transfer -> failure))
4;20;Every successful token transfer must log a public record of the transaction.;AG(transfer_success -> AX(log_public(transfer_record)))
5;20;A delegated transfer must fail if the spender isn’t approved or the owner lacks tokens.;AG((!approved(spender) || owner_balance < amount) -> AX(delegated_transfer -> failure))
6;20;Every successful delegated transfer must log a public record.;AG(delegated_transfer_success -> AX(log_public(delegated_transfer_record)))
7;20;Setting a spending limit must replace any previous limit for that spender.;AG(set_limit(spender, new_limit) -> AX(limit(spender) = new_limit))
8;20;Every new spending limit must log a public approval record.;AG(set_limit -> AX(log_public(approval_record)))
9;20;The token must report how many tokens a spender is allowed to move for an owner.;AG(EX(check_allowance(owner, spender) => allowance_is_number))
10;20;Creating new tokens must log a transfer from the zero address.;AG(mint_tokens -> AX(log_public(transfer(from=0x0, to=recipient))))
11;20;External systems must handle both success and failure responses from transfers/approvals.;AG(transfer_or_approval -> AX(response = success || response = failure))
12;20;Tokens must allow spending limits to be updated without first resetting to zero.;AG(update_limit(new_limit) -> EX(limit != 0))
13;165;A compliant contract must implement a function to check if it supports a given interface.;AG(EX(implements_function(check_interface_support(interface_id))))
14;165;The interface check function must return `true` when queried for its own interface ID (0x01ffc9a7).;AG(check_interface_support(0x01ffc9a7) -> AX(result = true))
15;165;The interface check function must return `false` when queried for the invalid ID (0xffffffff).;AG(check_interface_support(0xffffffff) -> AX(result = false))
16;165;The interface check function must use no more than 30,000 gas.;AG(EX(check_interface_support(interface_id) -> AX(gas_used <= 30000)))
17;165;To detect ERC-165 support, a contract must correctly respond to two static calls (with IDs 0x01ffc9a7 and 0xffffffff).;AG(static_call(0x01ffc9a7) -> AX(result = true)) AND AG(static_call(0xffffffff) -> AX(result = false))
18;721;Every NFT must have a unique ID that never changes and can be queried to find its owner.;AG(EX(query_owner(token_id) -> owner_exists)) AND AG(G(unique(token_id)))
19;721;A contract must track the number of NFTs owned by each address.;AG(EX(query_balance(address) -> AX(balance = count_owned_tokens(address))))
20;721;Only the NFT owner or an approved operator can transfer it. Transfers to the zero address must fail.;AG((sender != owner AND !is_approved_operator(sender, token_id)) -> AX(transfer -> failure)) AND AG(transfer(to = 0x0) -> AX(failure))
21;721;Safe transfers must check if the recipient is a contract capable of handling NFTs. If not, the transfer must fail.;AG(safe_transfer(to = contract) AND !implements_ERC721Receiver(to) -> AX(failure))
22;721;Approvals for specific NFTs must be revocable and emit an event when changed.;AG(revoke_approval(token_id) -> AX(log_event(approval_changed)))
23;721;Operators (like marketplaces) must be explicitly approved to manage all NFTs for an owner.;AG(set_operator_approval(owner, operator) -> AX(is_operator(operator, owner)))
24;721;Transfers must emit an event, including when NFTs are minted or burned.;AG(transfer OR mint OR burn -> AX(log_event(transfer_event)))
25;721;Contracts must implement ERC-165 to declare support for ERC-721.;AG(EX(implements_interface(0x80ac58cd)))
26;1155;A contract must track balances for each token type and owner.;AG(EX(query_balance(owner, token_id) -> AX(balance = get_balance(owner, token_id))))
27;1155;Batch balance checks must return balances for multiple owners and token IDs in one call.;AG(EX(batch_balance_check(owners[], token_ids[]) -> AX(result = map_balances(owners[], token_ids[]))))
28;1155;Transfers must fail if the sender lacks tokens or approval.;AG((balance(sender, token_id) < amount OR !is_approved(sender, token_id)) -> AX(transfer -> failure))
29;1155;Batch transfers must fail if array lengths mismatch or balances are insufficient.;AG((length(token_ids[]) != length(amounts[]) OR ∃i. balance(sender, token_ids[i]) < amounts[i]) -> AX(batch_transfer -> failure))
30;1155;Transfers to contracts must call a receiver hook and revert if the recipient rejects.;AG(transfer(to = contract) -> AX(call(receiver_hook) AND (receiver_hook_accepts -> success) AND (!receiver_hook_accepts -> revert)))
31;1155;Batch transfers to contracts must call a batch receiver hook.;AG(batch_transfer(to = contract) -> AX(call(batch_receiver_hook)))
32;1155;Operators (like marketplaces) must be explicitly approved to manage all tokens for an owner.;AG(set_operator_approval(owner, operator) -> AX(is_operator(operator, owner)))
33;1155;Minting tokens must emit a Transfer event with `_from` as the zero address.;AG(mint(token_id, to) -> AX(log_event(transfer(from=0x0, to=to, token_id))))
34;1155;Burning tokens must emit a Transfer event with `_to` as the zero address.;AG(burn(token_id, from) -> AX(log_event(transfer(from=from, to=0x0, token_id))))
35;1155;Contracts must implement ERC-165 and return `true` for the ERC-1155 interface ID (0xd9b67a26).;AG(EX(implements_interface(0xd9b67a26) = true))
36;4626;The vault must report the address of its underlying ERC-20 asset.;AG(EX(get_underlying_asset() -> AX(is_address(asset))))
37;4626;The vault must calculate the total value of underlying assets it manages, including fees and yield.;AG(EX(total_assets() -> AX(value = managed_assets + accrued_fees + yield)))
38;4626;Conversions between assets and shares must round down and exclude fees.;AG(convert(asset_amount) -> AX(shares = floor(asset_amount / exchange_rate_without_fees)))
39;4626;Deposits must mint shares to the receiver and emit a Deposit event.;AG(deposit(amount, receiver) -> AX(mint_shares(receiver) AND log_event(Deposit)))
40;4626;Withdrawals must burn shares from the owner, send assets to the receiver, and emit a Withdraw event.;AG(withdraw(amount, receiver, owner) -> AX(burn_shares(owner) AND transfer_assets(receiver) AND log_event(Withdraw)))
41;4626;Preview functions must return the exact outcome of deposits/withdrawals (including fees).;AG(EX(preview_deposit(amount) -> AX(result = simulate_deposit(amount)))) AND AG(EX(preview_withdraw(amount) -> AX(result = simulate_withdraw(amount))))
42;4626;Max functions must return the user's actionable limits (e.g., maxDeposit <= available liquidity).;AG(EX(max_deposit(user) -> AX(result <= available_liquidity)))
43;4626;Transfers of vault shares must comply with ERC-20 rules if enabled.;AG(ERC20_enabled -> AX(transfer_shares(from, to, amount) -> complies_with_ERC20))
44;4626;Vaults must implement ERC-20 metadata (name/symbol/decimals).;AG(EX(get_name() AND get_symbol() AND get_decimals() -> AX(all_defined)))
