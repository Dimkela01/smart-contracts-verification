Natural language requirement;CTL
A user cannot transfer more tokens than they have in their balance.;AG(balance[sender] ≥ amount → AX(balance[sender] = balance[sender] - amount))
Transfers must emit a Transfer event.;AG(transfer → AX(transfer_event_emitted))
An approved spender can transfer tokens on behalf of the owner.;AG(approved[spender][owner] ≥ amount → AX(balance[owner] = balance[owner] - amount ∧ balance[spender] = balance[spender] + amount))
The total supply of tokens must remain constant unless explicitly changed.;AG(total_supply = initial_supply)
Only the owner can approve a spender.;AG(!(caller = owner) → AX(!(approve(spender, amount))))
Transfers to the zero address are not allowed.;AG(!(receiver = 0x0) → AX(transfer(receiver, amount)))
The allowance for a spender must decrease after a transfer.;AG(transfer_with_allowance(owner, receiver, amount) → AX(allowance[owner][spender] = allowance[owner][spender] - amount))
Token transfers must not result in negative balances.;AG(transfer(receiver, amount) → AX(!(balance[sender] < 0)))
Only the owner or an approved operator can transfer a token.;AG((caller = owner ∨ caller = approved_operator) → AX(transfer(receiver, amount)))
Approval must be cleared when a token is transferred.;AG(transfer(receiver, token_id) → AX(approved[token_id] = null))
Only the owner can approve another address to manage the token.;AG(caller = owner → AX(approve(to, token_id)))
The balance of the sender must decrease by one after transferring a token.;AG(transfer(receiver, token_id) → AX(balance[sender] = balance[sender] - 1))
The interface check function must return `true` when queried for its own interface ID (0x01ffc9a7).;AG(interfaceId = 0x01ffc9a7 → AX(return = true))
The interface check function must return `false` when queried for the invalid ID (0xffffffff).;AG(interfaceId = 0xffffffff → AX(return = false))
A contract must correctly respond to two static calls (with IDs 0x01ffc9a7 and 0xffffffff).;AG((call(interfaceId = 0x01ffc9a7) ∨ call(interfaceId = 0xffffffff)) → AX(valid_response))
Only the NFT owner or an approved operator can transfer it.;AG((sender = owner[tokenId] ∨ operatorApproved[sender][owner]) → AX(transfer(tokenId)))
Safe transfers must check if the recipient is a contract capable of handling NFTs. If not, the transfer must fail.;AG((isContract(receiver) ∧ ¬implementsERC721(receiver)) → AX(¬safeTransfer))
Approvals for specific NFTs must be revocable and emit an event when changed.;AG(revoke_approval(tokenId) → AX(log_event[approval_changed]))
Transfers must emit an event, including when NFTs are minted or burned.;AG(transfer ∨ mint ∨ burn → AX(log_event[Transfer]))
Batch transfers must fail if array lengths mismatch or balances are insufficient.;AG(lengthMismatch ∨ insufficientBalance → AX(¬batchTransfer))
Transfers to contracts must call a receiver hook and revert if the recipient rejects.;AG(isContract(receiver) ∧ ¬receiver_accepts(tokenId) → AX(revert))
Minting tokens must emit a Transfer event with `_from` as the zero address.;AG(mint(tokenId, to) → AX(log_event[Transfer(from=0x0, to=to, tokenId=tokenId)]))
Burning tokens must emit a Transfer event with `_to` as the zero address.;AG(burn(tokenId) → AX(log_event[Transfer(from=owner, to=0x0, tokenId=tokenId)]))
Deposits must mint shares to the receiver and emit a Deposit event.;AG(deposit(amount, receiver) → AX(mint_shares(receiver) ∧ deposit_event_emitted))
Withdrawals must burn shares from the owner, send assets to the receiver, and emit a Withdraw event.;AG(withdraw(owner, receiver) → AX(burn_shares(owner) ∧ send_assets(receiver) ∧ withdraw_event_emitted))
Preview functions must return the exact outcome of deposits/withdrawals (including fees).;AG((preview(deposit) ∨ preview(withdraw)) → AX(return = amount + fees))
